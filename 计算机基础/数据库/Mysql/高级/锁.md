# 分类
**读锁** :也称为 共享锁 、英文用`S` 表示。针对同一份数据，多个事务的读操作可以同时进行而不会 互相影响，相互不阻塞的。

**写锁** :也称为 排他锁 、英文用`X`表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样 就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。 

> 对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。

# 表锁
## 读写锁
表级别的S锁、X锁
`LOCK TABLES t READ`:InnoDB存储引擎会对表 t 加表级别的 S锁 。 
`LOCK TABLES t WRITE`:InnoDB存储引擎会对表 t 加表级别的 X锁 。
## 意向锁
意向锁是一种表锁。
如果给某一行数据增加了排他锁，数据库会自动给更大一级，比如数据页或数据表增加意向锁。

意向锁分为两种:

**意向共享锁**(intention shared lock, IS):事务有意向对表中的某些行加共享锁(S锁)

**意向排他锁**(intention exclusive lock, IX):事务有意向对表中的某些行加排他锁(X锁)

即:意向锁是由存储引擎 ，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前， InooDB 会先获取该数据行 。

意向锁的并发性
- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。 SELECT column FROM table ... LOCK IN SHARE MODE;
- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。 SELECT column FROM table ... FOR UPDATE;

## 自增锁

## 元数据锁
当对一个表做增删改查操作的时候，加 MDL读锁;当要对表做**结构变更**操作的时候，加 MDL 写 锁。

# 行锁
MySQL服务器层没有实现行锁，行锁在存储引擎层实现。

## 记录锁 

## 间隙锁

解决幻读问题

## 临键锁
记录锁+间隙锁（锁键之前的一个gap）
Next-Key Locks是在存储引擎 innodb 、事务级别在 可重复读 的情况下使用的数据库锁，
innodb默认的锁就是Next-Key locks。

## 插入意向锁
InnoDB规 定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个 间隙 中 插入 新记录，但是现在在等待。
插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。

# 页锁
页锁的开销 介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。

> 每个层级的锁数量是有限制的，因为锁会占用内存空间， 锁空间的大小是有限的 。当某个层级的锁数量 超过了这个层级的阈值时，就会进行 锁升级 。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如 InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。


# 乐观锁和悲观锁
这两种锁是两种看待**数据并发的思维方式**

乐观锁和悲观锁并不是锁，而是锁的 设计思想 。

## 悲观锁
通过数据库的锁机制实现，保证操作的排他性。 Java中 `synchronized` 和 `ReentrantLock` 等独占锁就是 悲观锁思想的实现。

> mysql中`SELECT .. for update`会将所有**扫描的行**加锁

## 乐观锁
适用于多读的应用，可以提高吞吐量。

Java中`java.util.concurrent.atomic`包下的原子变量类就是使用了乐观锁
- 版本号机制
	- 在表中设计一个version字段 ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行 `update ... set version=version+1 where version=version`。此时 如果已经有事务对这条数据进行了更改，修改就不会成功。
- 时间戳CAS机制
	- 同上，version换时间戳 

> 乐观锁适合多读操作。不存在死锁，通过程序实现。
> 悲观锁适合多写操作。具有排他性。


# MVCC
### 隐藏字段、UNDO LOG、READ VIEW
隐藏字段：trx_id，roll_pointer
UNDO_LOG：read view生成的基础
READ_VIEW：生成某个版本的快照读

